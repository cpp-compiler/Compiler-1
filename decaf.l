%{
#include "head.h"           // Include some C++ headers
#include "ast.h"            // AST's interfaces
#include "tok.h"            // Header containing the tokens generated by bison parser
int yyerror(string s);
%}

/* Read only one input file */
%option noyywrap

SINGLE_QUOTES 			"\'"
DOUBLE_QUOTES 			"\""
COLON 					":"
SEMICOLON 				";"
COMMA 					","
OPENROUND 				"\("
CLOSEROUND 				"\)"
OPENSQUARE 				"\["
CLOSESQUARE 			"\]"
OPENCURLY 				"\{"
CLOSECURLY 				"\}"

WHITESPACES 			[ \t]+
CHAR 					[^\n]
CHAR_LITERAL 			{SINGLE_QUOTES}{CHAR}{SINGLE_QUOTES}
STRING_LITERAL 			\"(\\.|[^"])*\"

/* Regular Expressions related to special characters */
BING 					"!"
PLUS 					"+"
MINUS 					"-"
UNARY 					'-'
MULT 					"\*"
DIV 					"/"
MOD 					"%"
AND 					"&&"
OR 						"||"
ASSIGN 					"="
MULTASSIGN 				"\*="
DIVASSIGN 				"\\="
MODASSIGN 				"%="
PLUSASSIGN 				"+="
MINUSASSIGN 			"-="
EQ 						"=="
NEQ 					"!="
GT 						">"
LT 						"<"
GTEQ 					">="
LTEQ 					"<="

/* Regular Expressions related to handling numbers */
DIGIT 					[0-9]
DEC_LITERAL 			{DIGIT}+
HEX_LITERAL 			0[xX][{DIGIT}a-fA-F]+

/* Regular Expressions related to handling names */
CALLOUT 				"callout"
HEADER 					"class Program"
VOID                    "void"
IF                      "if"
ELSE                    "else"
RETURN                  "return"
BREAK                   "break"
CONTINUE                "continue"
FOR                     "for"
ID 						[A-Za-z_][A-Za-z{DIGIT}_]*

/* Regular Expressions related to handling types */
INTEGER 				"int"
BOOLEAN 				"boolean"
TRUE 					"true"
FALSE 					"false"

%%
{INTEGER} 				{    yylval.strVal = new string(yytext); return TYPES;    }
{BOOLEAN} 				{    yylval.strVal = new string(yytext); return TYPES;    }
{TRUE} 					{    yylval.strVal = new string(yytext); return BOOL_LITERAL;    }
{FALSE} 				{    yylval.strVal = new string(yytext); return BOOL_LITERAL;    }

{PLUS}					{    yylval.strVal = new string(yytext); return PLUS;    }
{MINUS}					{    yylval.strVal = new string(yytext); return MINUS;    }
{UNARY}					{    yylval.strVal = new string(yytext); return UNARY;    }
{MULT}					{    yylval.strVal = new string(yytext); return MULT;    }
{DIV}					{    yylval.strVal = new string(yytext); return DIV;    }
{MOD} 					{    yylval.strVal = new string(yytext); return MOD;    }
{AND} 					{    yylval.strVal = new string(yytext); return AND;    }
{OR} 					{    yylval.strVal = new string(yytext); return OR;    }
{ASSIGN} 				{    yylval.strVal = new string(yytext); return ASSIGN;    }
{PLUSASSIGN} 			{    yylval.strVal = new string(yytext); return PLUSASSIGN;    }
{MINUSASSIGN} 			{    yylval.strVal = new string(yytext); return MINUSASSIGN;    }
{NEQ} 					{    yylval.strVal = new string(yytext); return NEQ;    }
{EQ} 					{    yylval.strVal = new string(yytext); return EQ;    }
{GTEQ} 					{    yylval.strVal = new string(yytext); return GTEQ;    }
{LTEQ} 					{    yylval.strVal = new string(yytext); return LTEQ;    }
{GT} 					{    yylval.strVal = new string(yytext); return GT;    }
{LT} 					{    yylval.strVal = new string(yytext); return LT;    }
{BING}					{    yylval.strVal = new string(yytext); return BING;    }

{DEC_LITERAL}			{    yylval.intVal = atoi(yytext); return DEC_LITERAL;    }
{HEX_LITERAL}			{    sscanf(yytext, "%d", &yylval.intVal); return HEX_LITERAL;    }

{CALLOUT} 				{    return CALLOUT;    }
{HEADER} 				{    return HEADER;    }
{VOID} 				    {    return VOID;    }
{IF}                    {    return IF;    }
{ELSE}                  {    return ELSE;    }
{FOR}                   {    return FOR;    }
{RETURN}                {    return RETURN;    }
{BREAK}                 {    return BREAK;    }
{CONTINUE}              {    return CONTINUE; }
{ID} 					{    yylval.strVal = new string(yytext); return ID;    }

{WHITESPACES} 			{    }
[\n] 					{    yylineno++;    }
{CHAR_LITERAL} 			{    yylval.strVal = new string(yytext); return CHAR_LITERAL;    }
{STRING_LITERAL} 		{    yylval.strVal = new string(yytext); return STRING_LITERAL;    }
. 						{    return yytext[0];    }
%%
